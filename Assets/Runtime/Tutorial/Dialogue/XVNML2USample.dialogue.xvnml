<source name::"XVNML2USample.Dialogue.XVNML">
     <dialogue #override name::"XVNML2U Sample" #enableMigration>
          @ {
               $_defaultTextSpeed
               |$_switchToPropFadeInMode
               |set_prop_scale::(5i, 5i)
               |pass}<
          @ {style::"title"}Welcome to {bold|emphasis|color::"yellow"}XVNML2U!{color_end|emphasis_end|bold_end|style_end}<
          @ This package{$_think} demonstrates the capabilities in which the XVNML
           Class Library is capable of{delay::500|clr}when used with the Unity Game Engine.<
          @ What you see here{delay::750} is a normal dialogue.<
          @ And {insert::"THIS"|delay::1000} is a dialogue with{set_text_speed::60} a
           looooooooooooooooooooooooooooooooooooooooooooooooooooot of {$_defaultTextSpeed}charisma!!!!<
          @ And with a normal XVNML Dialogue Control component, you can run whatever
           dialogue you want.<
          @ This is just a sample of what XVNML can do.<
          @ XVNML is a powerful tool with an {em}EMPHASIS{emed} in story telling.<
          @ And we're starting our journey off by integrating XVNML to Unity 
          {paren}hence "XVNML2U"{paren_end}.<
          @ We're very excited to see how you'll put this tool to the ultimate test.<
          ? What's boning on?>>
          (
               ("Nothing")>
                    @ I see.<<
          )
          
          #//Main Menu

          ["Main-FirstTime"]
          ? So, what would you like to know about XVNML or about XVNLM2U?{$_pauseAndHide}>>
          (
               ("What is XVNML?")>                @ {$_chapter1}<<
               ("Why XVNML?")>                    @ {$_chapter2}<<
               ("What is XVNML2U...")>            @ {$_chapter3}<<
               ("Integrate XVNML Manually...")>   @ {$_chapter4}<<
               ("Some Best Practices...")>        @ {$_chapter5}<<
          )

          ["Main"]
          @ And with that said...<
          ? Is there anything else you would like to know?{$_pauseAndHide}>>
          (
               ("What is XVNML?")>                @ {$_chapter1}<<
               ("Why XVNML?")>                    @ {$_chapter2}<<
               ("What is XVNML2U...")>            @ {$_chapter3}<<
               ("Integrate XVNML Manually...")>   @ {$_chapter4}<<
               ("Some Best Practices...")>        @ {$_chapter5}<<
               ("End Demo")>                      @ {$_conclude}<<
          )
               
          #//endregion

          #//What is XVNML

          ["P1"]
          @ {$_defaultTextSpeed}XVNML stands for
           "X-Tensible Visual Novel Mark-Up Language."<
          @ It takes the usual format that people are used to when
           storing dialogue data, and caters it towards those making visual novels.<
          @ Despite having "Visual Novel" in the name as well as stating
           that it caters towards those making them, you can use it outside the realm
           of an actual visual novel.<
          @ All that it is used for is to create story-centric content a lot more
           intuitive.<
          @ We've originally created a precursor to XVNML called DSL {paren}Dialogue Scripting Language{paren_end}
           and it's code-base was very fragile, inaccurate, slow, and unreliable.<
          @ So we took the features from DSL, and made it better, making it more like HTML.<
          ? It also provides a syntax language called Skriptr, which is how you'll mainly be
           typing out dialogue.>>
          (
               ("Skriptr? What is that?")>
               @ {jump_to::"P1-Skriptr"|pass}<<
          )

          ["P1-Skriptr-Incorrect"]
          @ {$_defaultTextSpeed}Unfortunately, that's not the correct answer...
          {jump_to::"P1-Skriptr-CorrectAnswer"}<

          ["P1-Skriptr"]
          @ {$_defaultTextSpeed}Skriptr is the syntaxical language used in tandem with XVNML to...<
          @ type out dialogue.<
          @ Each Skriptr line must first be given a role to play.<
          @ It can either take in a Declarative Role {paren}denoted by the {quot|at|quot} symbol{paren_end}...<
          @ Or a Interrogative Role {paren}denoted by the "?" symbol {paren_end}...<
          @ When given a Declarative Role, it'll type out dialogue to the screen as normal...{delay::500|clr}
          Just like what you are seeing now.<
          @ However, if given a Interrogative Role...<
          @ The dialogue acts as a Prompt in which the user must answer to.<
          ? For example, how many states does the United States have?>>
          (
               ("50")>
                    @ That is correct!<<
               ("13")>
                    @ {jump_to::"P1-Skriptr-Incorrect"|pass}<<
               ("3")>
                    @ {jump_to::"P1-Skriptr-Incorrect"|pass}<<
               ("I honestly don't know...")>
                    @ That's okay if you don't know.<<
          )

          ["P1-Skriptr-CorrectAnswer"]
          @ {$_defaultTextSpeed}There are 50 states that makes up the United States of America.<
          @ Awesome huh?<
          @ Let's take a look at the file where we have all of this dialogue.<
          @ And don't freak out when you look at it.<
          @ I promise you, you'll understand it faster than I can finish this sentence.<
          @ Search up and find a file called {quot}XVNMLEssentials.main.xvnml{quot}.<
          @ Open that in VSCode and go to Line 61.<
          @ You will see that that's the first thing that we started off with.<
          @ And if you jump to Line 194, you'll exactly what I'm currently saying.<
          @ You notice that it's just the {quot|at|quot} symbol when stating a
           Declarative Role on a Skriptr line.<
          @ However, if you've defined Cast members within your XVNML project...<
          @ You can set them as a speaker!<
          @ {$_initializeCastMotionSettings}For example...<
          @??? {cue_cast::("Hana","Center")}Hello!<
          @??? My name is Hana!<
          @Hana>Happy {react::"Jump"}It's very nice to meet you!<
          @ Anything after and before actual dialogue is known as the Cast Signature.<
          @ {exp::("Hana", "Smile")|react::("Hana", "Jump")}If you look at Line 204, this is considered a Normal Cast Signature.<
          @ It's the most common signature that you'll see inside an XVNML document.<
          @ Anything without a name is considered a Narrative Cast Signature.<
          @ As the name suggests, it's meant to denote that the Narrator is speaking.<
          @??? If there's a {quot|qm|qm|qm|quot} in place of the name...<
          @??? This is known as the Anonymous Cast Signature.<
          @* And anything with an {quot|aster|quot} is consider a Persistent Cast Signature.<
          @ The general format of a Cast Signature is the following...<
          @ {paren}{at}{pipe}{qm}{paren_end}{tag_end}{brack}Expressions{brack_end}{tag_end}{brack}Voice{brack_end}<
          @ {move_cast::("Hana",-1325)}It's definitely a lot to keep up with, but that's what the XVNMLEssentials guide is for...<
          @ To help you get in touch with XVNML.<
          ? Would you like to know more about Cast Signatures?>>
          (
               ("Yes")> @ {pass}<<
               ("No")>
                    @ That's alright.<
                    @ You have sample files to look over and study.<
                    @ However, if you need more context for something, or understanding...<
                    @ You can always look at the documentation that comes with XVNML2U...<
                    @ As it goes more in-depth with how to work with XVNML.
                    {$_main}<<
          )

          ["P1-Skriptr-CastSignatures-Main-FirstTime"]
          ? {$_defaultTextSpeed}Which Cast Signature would you like to know about?{$_pauseAndHide}>>
          (
               ("Narrative Cast Signatures...")>
                    @ {jump_to::"P1-Skriptr-CastSignatures-Narrative"|pass}<<
               ("Normal Cast Signatures...")>
                    @ {jump_to::"P1-Skriptr-CastSignatures-Normal"|pass}<<
               ("Persistent Cast Signatures...")>
                    @ {jump_to::"P1-Skriptr-CastSignatures-Persistent"|pass}<<
               ("Anonymous Cast Signatures...")>
                    @ {jump_to::"P1-Skriptr-CastSignatures-Anonymous"|pass}<<
          )

          ["P1-Skriptr-CastSignatures-Main"]
          ? {$_defaultTextSpeed}Which Cast Signature would you like to know about?{$_pauseAndHide}>>
          (
               ("Narrative Cast Signatures...")>
                    @ {jump_to::"P1-Skriptr-CastSignatures-Narrative"|pass}<<
               ("Normal Cast Signatures...")>
                    @ {jump_to::"P1-Skriptr-CastSignatures-Normal"|pass}<<
               ("Persistent Cast Signatures...")>
                    @ {jump_to::"P1-Skriptr-CastSignatures-Persistent"|pass}<<
               ("Anonymous Cast Signatures...")>
                    @ {jump_to::"P1-Skriptr-CastSignatures-Anonymous"|pass}<<
               ("I've learned everything there is to know about Cast Signatures...")>
                    @ That's great to hear!
                    {jump_to::"P1-Skriptr-CastSignatures-Complete"}<<
          )

          ["P1-Skriptr-CastSignatures-Narrative"]
          @ {$_defaultTextSpeed}A Narrative Cast Signature denote that the narrator is
           speaking.<
          @ You can not set an expression for the narrative...<
          @ But you can set a voice.<
          @ We don't have a voice set up for the narrator though...<
          @ But that is the only valid syntax that it has.<
          @ There is a hidden benefit of just using a Narrative Cast Signature.<
          @ And that is if you just want to execute macros alone.<
          @ When doing so, a macro to keep in mind is the {quot}pass{quot} macro.<
          @ This macro simpily bypasses user input, and will immediately go to the
           next SkriptrLine.<
          @ So any macros that does some form of configuration or setup...<
          @ You would use the Narrative Cast Signature, and create your Macro Invocation Block.<
          @ To invoke more than one macro, you would seperate each invocation with {quot}{pipe}{quot}.<
          @ It's a hidden benefit of the Narrative Cast Signature significant enough to be mentioned...<
          @ Because even the XVNML file being used to display all of this uses this method from
           time to time.<
          @ Never forget to add the {quot}pass{quot} macro after all prior macro invocations.<
          @ Or you will be presented with a empty dialogue box, waiting for you to send an input.<
          @ That is unless you have the {quot}{hash}dontDetain{quot} flag set.{jump_to::"P1-Skriptr-CastSignatures-Main"}<
          
          ["P1-Skriptr-CastSignatures-Normal"]
          @ {$_defaultTextSpeed}A Normal Cast Signature denotes that a character is speaking.<
          @Jimmy You can put whatever name in here...<
          @* However, if that cast was not defined, you can't using expressions
           or voices.<
          @Hana {cue_cast::"Center"}However for me, I am a defined Cast member!<
          @*>Happy I can change expressions {paren}as you saw earlier...{paren_end}<
          @*>V::Wow And I can play a voice based on the how the Normal Cast
           signature is formed.<
          @ {exp::("Hana","Smile")}Nice work, Hana. I'm really{exp::("Hana","Happy")|react::("Hana","Jump")} proud of you.<
          @Hana Hehe!<
          @ {move_cast::("Hana",-1325)}An added bonus to Normal Cast Signatures comes with the
           different Cast-Specific Macros exclusive to Unity...<
          @ Such as "move_cast", "cue_cast", "cast_enters_from", "set_cast_motion", and "set_cast_motion_duration".<
          @ In fact, we happened to use those macros just demonstrating how Normal Cast Definitions work.<
          @ You'll soon realize that you can do a lot of cool stuff with XVNML2U.<
          @ For example, Cast Reactions {paren}which we had used about 3 times so far{paren_end}.<
          @ Last thing that is nice to know about Normal Cast Signatures is that by default...<
          @ It follows the "Role{tag_end}Name{tag_end}Expression{tag_end}Voice" format.<
          @ However, you can omit either an expression or a voice.<
          @ To omit a voice, just name the cast expressions as normal.<
          @ To omit an expression, use the "V{colon|colon}" prefix, followed by the voice name.<
          @ You can even change the order from Expression{tag_end}Voice to Voice{tag_end}Expression!<
          @ You just need to make sure that an Expression Prefix {paren}E{colon|colon}{paren_end}
           and a {paren}V{colon|colon}{paren_end} before the expression name and voice name
           respectively.
          {jump_to::"P1-Skriptr-CastSignatures-Main"}<
          
          ["P1-Skriptr-CastSignatures-Persistent"]
          @ {$_defaultTextSpeed}A Persistent Cast Signature takes the last cast member to speak, and
           carries them over.<
          @ The keywords here is {quot}last cast member{quot}.<
          @ Persistent Casts doesn't work if the previous speaker was
           Narrative or Anonymous.<
          @ So the last Normal Cast Signature specified prior to using a
           Persistent Cast Signature...<
          @ Will denote that the cast is still speaking.<
          @ And because of this, you can treat Persistent Cast Signatures as a
           short-cut to Normal Cast Signatures.<
          @ You just don't have to type the name out {paren}which is the core reasoning
           for having a Persistent Cast Signature{paren_end}.<
          @ You can set the Expressions and Voices of the previous mentioned cast
           as normal.
          {jump_to::"P1-Skriptr-CastSignatures-Main"}<
          
          ["P1-Skriptr-CastSignatures-Anonymous"]
          @ {$_defaultTextSpeed}An Anonymous Cast Signature denotes that the speaker is unknown.<
          @ You really can't do much with an Anonymous Cast Signature.<
          @ However, by combining macros, you can set a cast on to the screen
           and still change their expressions and voices.<
          @ You would have to do that until you switch to the Normal Cast Signature
           on the next line.<
          @  If you have checked out Persistent Cast Signatures, you've learned that
           an Anonymous Cast Signature has no persistency.<
          @ So, you'll have to keep on typing {quot|qm|qm|qm|quot} until
           the speaker is known to the player.
          {jump_to::"P1-Skriptr-CastSignatures-Main"}<
          
          ["P1-Skriptr-CastSignatures-Complete"]
          @ {$_defaultTextSpeed}It's definitely a lot, huh?<
          @ You can always look back into {quot}XVNMLEssentials.main.xvnml{quot}
           to get a feel of how Skriptr works.<
          @ One last thing to cover before we conclude is that you can
           name a SkriptrLine.<
          @ Named Skriptr Lines enables you to control the flow of dialogue.<
          @ You might of seen it in the previously mentioned file.<
          @ You may have also seen words in curly braces.<
          @ That is what's known as a Macro Invocation Block.<
          @ And words like {quot}quot{quot}, {quot}jump_to{quot}, {quot}space{quot}...<
          @ Those are macros, and they have established an endpoint to a method call.<
          @ You'll learn more about Macros once you've opened the {quot}MacroLibraries{quot} scene.<
          @ But you can use the {quot}jump_to{quot} macro call and specify a name.<
          @ Sadly, if you need to check a condition before making a jump, the macro would have to
           be created manually...<
          @ Or you would have to use some code-behind to achieve that.<
          @ For now, that's all we have to cover for Skriptr.<

          ["P1-Tags"]    
          @ {$_defaultTextSpeed}The last thing that we need to mention for XVNML is Tags.<
          @ Since XVNML is a mark-up language, it'll be closely related
           to something like HTML or XML.<
          @ However, there's a couple of features that every tag has.<
          @ To address the elephant in the room...<
          @ The {tag}dialogue{tag_end} tag is very unique.<
          @ There are no tags that can make the {tag}dialogue{tag_end} as
           its parent tag.<
          @ You can try, but the Skriptr Parser will mess up...<
          @ Causing all sorts of havoc.<
          @ And...
          {delay::1000}
          {insert::"Ha"|delay::500}
          {insert::"ha"|delay::500}
          {insert::"ha"|delay::500}
          ...
          {pause|clr}
          We don't want that, now do we?<
          @ With that said, every tag will have 3 default parameter...<
          @ the {quot}name{quot} parameter...<
          @ the {quot}id{quot} parameter...<
          @ and the {quot}altName{quot} parameter.<
          @ And there are also another type of parameter known as a Flag Parameter.<
          @ You may encounter some as you learn XVNML...<
          @ They will always have a {hash} prior to a name.<
          @ A very handy flag that you can use for dialogues is called {quot}{hash}dontDetain{quot}<
          @ This will automatically have all dialouge bypass human input...<
          @ And will continue to the next line of dialogue.<
          @ You can even set a {quot}detainPassDelay{quot} value, which will wait for
           a set amount of milliseconds before doing the bypass.<
          @ And finally, with the {quot}{hash}allowInputOnDetainPassDelay{quot} allows
           the player to send input until after the time set by the...<
          @ {quot}detainPassDelay{quot} elapsed.<
          @ Very handy stuff, huh?<
          @ There will be a .pdf file in the {quot}documentations{quot} folder.<
          @ In that will list all valid parameters and flags for each tag.<
          @ You can also find a list of macros and their required arguments...<
          @ learn how to create Custom Macros and attaching their endpoints...<
          @ AND...{delay::1000} how to create Custom Tags!<
          @ That's right, you can define your own tags.<
          @ The documentation has all of that information checked.<
          @ Be sure to read it thoroughly.<
          @ You'll soon realize that you can do a whole lot with XVNML
           as you explore more into the XVNML2U package.
          {$_main}<

          #//endregion
     
          #//Why Create XVNML

          ["P2"]
          @ {$_defaultTextSpeed}{quot}Why{quot} is a very good question.<
          @ Primarily because we already have certain tools and
           packages that makes creating dialogue and providing story-centric...< 
          @ elements to your games very easily.<
          @ However, with XVNML, we took the {quot}common{quot} way of storing
           dialogue data, and brought it to a level where you can treat an
           XVNML file like it was a Word document for a screenplay.<
          @ We've also stack different tools and features that makes reading
           data from this as simple as working with HTML...<
          @ And even if you haven't worked with HTML, it's a very small
           barrier-of-entry.<
          @ That's why something like XVNML2U exists{semi} to
           teach you how to type XVNML files, and showcase how
           to use XVNML to power your dialogue systems.<
          @ XVNML primarily uses Skriptr to type out all of the dialogue.<
          @ Skriptr is made so that people such as those coming from Ren'Py can
           easily learn and use.<
          @ Besides denoting who the {quot}speaker{quot} is, Skriptr is
           very different from Ren'Py.<
          @ However in the future, Skriptr would have ungone a numerous
           amount of changes and updates...<
          @ So perhaps it'll become a little more like Ren'Py later on.<
          @ The benefit for using XVNML part of your game development workflow is
           the fact that all the content is right in front of you, and
           is seperate from the Unity Editor.<
          @ No need to create a Scriptable Object that holds all of your
           dialogue data...<
          @ You don't have to download a Node-Based Visual Language for arranging dialogues and
           handling events...<
          @ And there's no need to parse a JSON or XML manually...<
          @ And with XVNML2U, the integration has already been done for you, so you
           can start creating your dream game sooner than later.<
          @ Of course, if anything, you can always get the binary for XVNML and do the integration yourself...<
          @ Allowing you to reduce the amount of bloat that you get from XVNML2U.<
          @ There will be a whole section on how to integrate XVNML into your own projects without
           the use of XVNML2U.
          {$_main}<

          #//endregion    

          #//What is XVNML2U

          ["P3"]
          @ {$_defaultTextSpeed}XVNML2U...<
          @ Why...{delay::1000|clr}It's this one of course!<
          @ The Unity Package that you are using right now!<
          @ Jokes aside, XVNML2U is a Unity Package that integrates
           XVNML to create an effective Dialogue System.<
          @ That's about it really, other than with the power of XVNML...<
          @ You can do a lot more with XVNML2U than you can with just reading
           data from an XVNML file.<
          @ XVNML2U provides you with Unity-Exclusive Tags, Macros, and features
           outside of native usage of XVNML...<
          @ Such as loading images, using Cast Data to display a character...<
          @ Playing sound effects and background music, integrate a prompt system using
           SkriptrLine data...<
          @ Just to name a few.<
          @ XVNML2U provides you with basic gameObjects that you can use to your advantage.<
          @ If you just want something basic, with no prompts, image loading or anything...<
          @ Use the BasicModuleKit.<
          @ If you want something more like a Visual Novel, you can use the VNModuleKit.<
          @ There's other important components as well, such as the DialogueProcessAllocator
           which takes advantage of XVNML's feature of {quot}Concurrent Dialogue Processes{quot}.<
          @ Concurrent Dialogue Processes {paren}or CDP{paren_end} is a fancy way of saying...<
          @ {quot}You can render more than one dialogue on a screen.{quot}<
          @ So, if you ever want to simulate a crowd of people taking in the middle of
           Town Square...<
          @ You'd utilize CDPs to achieve that.<
          @ However, it's required to have the DialogueProcessAllocator in your scene 
          {paren}or if you are integrating XVNML on your own, something equivalent to it.{paren_end}<
          @ Because it'll allow you to not only run multiple dialogue at once,
           you can use it to send actions to a target DialogueControl...<
          @ {paren}which is another important component{paren_end}.<
          @ The Dialogue Control {paren}and many other components like it{paren_end}...<
          @ allows you to use UnityEvents to have certain objects to certain things...<
          @ For example, if dialogue starts playing, have the dialogue box fade in...<
          @ And when every line has been said, have the dialogue box fade out on the
           "onFinish" event.<
          @ Another example is when you are using XVNMLTextRenderer component...<
          @ With the OnTextChange event, you can have it make a noise, or use the callback to animate
           TextMeshPro {paren}with whatever TMP effects tool you are using{paren_end}.<
          @ Utilizing these UnityEvents{delay::500}, you can truly give your dialogue personality some PAZZAZ!<
          @ There are other important Unity components that you can benefit from with XVNML2U...<
          @ Such as the XVNMLLogListener, XVNMLActionScheduler, and XVNMLInputManager.<
          ? Would you like to learn more about these components?>>
          (
               ("Yes")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents"|pass}<<
               ("No")>
                    @ That is fine<
                    @ You can always look at the documentation for later.
                    {jump_to::"P3-XVNML2U-UnityComponents-Complete"}<<
          )

          ["P3-XVNML2U-UnityComponents-Main-FirstTime"]
          ? {$_defaultTextSpeed}Which component are you interested in learning?{$_pauseAndHide}>>
          (
               ("The LogListner Component")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-LogListener"|pass}<<
               ("The ActionScheduler Component")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-ActionScheduler"|pass}<<
               ("The InputManager Component")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-InputManager"|pass}<<
               ("The Stage Component")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-Stage"|pass}<<
               ("The XVNMLPromptControl Component")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-XVNMLPromptControl"|pass}<<
               ("The XVNMLAudioController")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-XVNMLAudioController"|pass}<<
               ("The ResponseControl Component")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-ResponseControl"|pass}<<
               ("The Confirm Marker")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-ConfirmMarker"|pass}<<
          )

          ["P3-XVNML2U-UnityComponents-Main"]
          ? {$_defaultTextSpeed}Are there any more components you would like to learn about?{$_pauseAndHide}>>
          (
               ("The LogListner Component")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-LogListener"|pass}<<
               ("The ActionScheduler Component")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-ActionScheduler"|pass}<<
               ("The InputManager Component")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-InputManager"|pass}<<
               ("The Stage Component")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-Stage"|pass}<<
               ("The XVNMLPromptControl Component")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-XVNMLPromptControl"|pass}<<
               ("The XVNMLAudioController")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-XVNMLAudioController"|pass}<<
               ("The ResponseControl Component")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-ResponseControl"|pass}<<
               ("The Confirm Marker")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-ConfirmMarker"|pass}<<
               ("I have learned enough about XVNML2U components...")>
                    @ {jump_to::"P3-XVNML2U-UnityComponents-Complete"|pass}<<
          )

          ["P3-XVNML2U-UnityComponents-LogListener"]
          @ {$_defaultTextSpeed}The LogListener Component is a very handy component when it comes to receiving internal messages...<
          @ from the XVNML binary.<
          @ From running the tokenizer, to analyzing Tags and Skriptr Lines with the parser...<
          @ to even tags being resolved to their respective types...<
          @ the LogListner Component takes those messages, and allows them to be displayed
           on the Unity Console.<
          @ You can toggle off if you want to receive any logs {paren}because we know
           how annoying it can be being bombarded with messages...{paren_end}<
          @ You can even toggle on and off the different kinds of messages you receive.<
          @ You'll receive either a Verbose message {paren}with not-so important pieces of information{paren_end}...<
          @ Warning messages...<
          @ And of course Error messages.<
          @ If you wanted to, you could have the Editor's PlayMode status as {quot}paused{quot}
           every time an error message is received from either...<
          @ The Tokenizer...<
          @ Parser...<
          @ Tags...<
          @ Macro Invocations...<
          @ And much more.<
          @ A really handy component to use, but definitely isn't need.<
          @ It is recommended to have this component within your game scene so that you
           can undergo the proper debugging in your code.<
          @ However, sometimes it could be an issue from our end.<
          @ You can always report the issue on GitHub, stating what you are trying to accomplish...<
          @ The message you are receiving...<
          @ And if it's replicable or not.<
          @ We will review and resolve the issue as promptly as possible...<
          @ To assure that you are using XVNML2U to its fullest.<
          @ Because no one likes to have to deal with errors slowing them down from their progress.<
          @ We know we don't.<
          @ And neither does Hana.
          {jump_to::"P3-XVNML2U-UnityComponents-Main"}<

          ["P3-XVNML2U-UnityComponents-ActionScheduler"]
          @ {$_defaultTextSpeed}The ActionScheduler Component is one of the most important components to have
           within your project.<
          @ It's responsibility is to add pending actions on a queue for it to be properly executed.<
          @ Objects that do send an action to the ActionScheduler usually inherit from the
           MonoActionSender class.<
          @ Without it, you can't extend any functionalities you want to include, since the backend of
           XVNML2U runs on a seperate thread...<
          @ And can not be called on the Unity Thread.<
          @ There are a few exceptions.<
          @ However, if you are implementing your own Macros or Tags...<
          @ And you receive an error message in Unity that you must modify something on the Main Thread{del::500|clr}
          {paren}that being Unity's Thread{paren_end}...<
          @ Try finding a way to incorporate your code using the MonoActionSender class.<
          @ With it, you'll be given the {quot}SendNewAction{quot} method.<
          @ It takes in an anonymous method where it must return a WCResult.<
          @ You can either return an {quot}Ok{quot} {paren}a successful execution{paren_end}...<
          @ an {quot}Unknown{quot} {paren}which it will retry the action{paren_end}...<
          @ or an {quot}Error{quot} {paren}an unsuccessful execution{paren_end}...<
          @ However, this must be noted...<
          @ By return an {quot}Unknown{quot} WCResult, it'll repeat the action until you either receive...<
          @ an {quot}Ok{quot} result, or an {quot}Error{quot} result.<
          @ So use this sparingly{semi} keep it between an {quot}Ok{quot} result...<
          @ and an {quot}Error{quot} result.<
          @ That way, you'll never come across any issues down the line.<
          @ XVNML2U uses the {quot}SendNewAction{quot} method for it's MacroLibrary and within the
           DialogueControl component.<
          @ So having an ActionScheduler within your scene is crucial if you want Unity-Specific Macros
           and Tags to work inside your XVNML file.<
          @ This can especially be said for your own Macros and Tags.<
          @ In the future, we may have it where it's not required to add an ActionScheduler as a component.<
          @ But for now, make it your mission to include this component inside your project.<
          @ Otherwise, any XVNML files that uses those Macros will not invoke.<
          @ The same thing goes with creating your own custom tags.<
          @ However, since you are inheriting from UserDefinedTag, you won't be able to
           use MonoActionSender.<
          @ The solution to that is using the static variant of SendNewAction via the ActionScheduler itself.<
          @ Honestly, you don't have to inherit any of your classes with the MonoActionSender, and opt for
           using the static method variant instead...<
          @ Allowing you to inherit you class a different way.<
          @ Though it's best to use the static method if you really need to.<
          @ If you know your class will be a Unity Component inside your gameObject...<
          @ have it inherit from MonoActionSender.<
          @ Otherwise, switch to using the static variant of that method.
          {jump_to::"P3-XVNML2U-UnityComponents-Main"}<

          ["P3-XVNML2U-UnityComponents-InputManager"]
          @ {$_defaultTextSpeed}The InputManager Component utilized defined keycodes inside your XVNML file.<
          @ This component is also an important one.<
          @ In order to be able to do things like progressing the dialogue...<
          @ you need this component in your Game Scene.<
          @ The event that triggers from signaling an input from you defined keycodes...<
          @ is know as that keycode's {quot}purpose{quot}.<
          @ However, inside XVNML2U, it's called the {quot}InputEvent{quot}.<
          @ Very inconsistent.{delay::750} I know...<
          @ You don't have to rub it in.<
          @ There are pre-defined Purposes or InputEvents that you can put inside your keycode definition...<
          @ Those being PROCEED, SAVE, LOAD, QUICK_SAVE, QUICK_LOAD, PAUSE, RESUME, SHOW_LOG...<
          @ MAIN_MENU, NAVIGATE_LEFT, NAVIGATE_DOWN, NAVIGATE_RIGHT, and NAVIGATE_UP.<
          @ However, you can set up to 32 presets for you {quot}the creator{quot} to use.<
          @ You decide what presets does what, and you can annotate that by using the {quot}description{quot}
           tag parameter on the {tag}keycode{tag_end} tag.<
          @ You could even be descriptive by simply using the tags name, making the {quot}description{quot}
           parameter an option.<
          @ You can even put more than 1 keycode with the same Purpose{slash}InputEvent...<
          @ Allowing for XVNML2U to accept more than one input.<
          @ So keep that in mind.{jump_to::"P3-XVNML2U-UnityComponents-Main"}<

          ["P3-XVNML2U-UnityComponents-Stage"]
          @ {$_defaultTextSpeed}The Stage Component utilizes defined scenes and cast insider your XVNML file.<
          @ All scenes defined in the {tag}sceneDefinitions{tag_end} tag have a reference to an defined
           image.<
          @ Whether the definitions of those Images are within the Proxy file...<
          @ Or pointing to a Source file.<
          @ The same logic applies for {tag}castDefinitions{tag_end}.<
          @ The data contained in a scene's corresponding image is loaded and converted to a tangible
           Unity Asset at Runtime.<
          @ Once XVNML2U reads those bytes, it'll cache the final produce until it is needed using the
           "cue_scene" Macro.<
          @ At that point, it'll use the information cached, and set the image to be seen in the Game View.<
          @ {use_scene::"OutsideOfSchool"}Like so.<
          @ You may even set a layer in which the scene will be viewed, allow for a scene made with
           different parts.<
          @ This is all that the SceneController does, and you would have to create your own macro
           to do fancy stuff, such as changing the image's RGBA values.<
          @ {clear_scene}You can unload the scene by using the "clear_scene" macro.<
          @ Without passing an argument, it'll clear the only or last image that was loaded.<
          @ Passing in a value, such as which layer to target {paren}a numerical value{paren_end}
           or by the name of the scene {paren}which the SceneController will find the layer with that image{paren_end}...<
          @ You can remove those specific scenes, or replace them using the "cue_scene" macro
           and override a layer with the new image.<
          @ Again, that's basically the only thing that you can you do with the SceneController.<
          @ However, there will me more functionalities for it in the later versions of XVNML2U to come.<
          @ This isn't so much for Casts however.<
          @ You can cue a cast and set them at a position using the "cue_cast" macro.<
          @ You can either position them using "Left", "Right", and "Center".<
          @ Or by a relative shift using a numerical value.<
          @ You can even specify an offset.<
          @ {
               $_initializeCastMotionSettings
               |cue_cast::("Hana","Center")
          } There are many macros that you can use to influence how your target cast enters the stage.<
          @ You can specify the motion {paren}either Instant or Interpolation{paren_end}...<
          @ The duration that it takes for her to enter the stage {paren}this is if you set her motion as
           Interpolation{paren_end}...<
          @ And you can decide from which side she enters from {paren}Left, Right, or Center{paren_end}.<
          @Hana>Happy>Wow {react::"Jump"}That's right!<
          @* It may seem a lot, but it's really that simple.<
          @*>Smile So long that you thoroughly read through the documentation...<
          @*>Happy {react::"Jump"}It shouldn't be a problem at all!<
          @ {exp::("Hana"|"Smile")}After cuing a cast member on to the stage, you can move her around
           by using the {quot}move_cast{quot} macro.<
          @ {move_cast::("Hana", -750)}We can move her to the left...<
          @ {move_cast::("Hana", 750)}Move her to the right...<
          @ {move_cast::("Hana", 0)}Put her back in center...<
          @ And we can do the same thing, but this time with Teleportation...{$_resetCastMotionSettings}<
          @Hana {move_cast::-750}I teleport to the left...<
          @*>Happy {move_cast::750}I teleport to the right...<
          @* {move_cast::0}And now I'm back at center stage!<
          @ {set_cast_motion::"Interpolation"}Pretty mind blowing...{exp::("Hana", "Smile")} We know...<
          @ We really appreciate{exp::("Hana", "Happy")} the demonstration, Hana!<
          @Hana {react::"Jump"}Any time, chief!<
          @ {move_cast::("Hana", -1325)}Basically, the stage is doing exactly what a stage is suppose to do...<
          @ You set up a scene, and cast members can "walk" on stage.<
          @ And you can control the timing of that using the prementioned Macros within you Skriptr lines!<
          @ You would have to memorize some of these macros to get use to them.<
          @ But once you know them, you're basically writing your own Screenplay!<
          @ Astonishing is XVNML2U.<
          @ You can create macros that control both the scenes and cast members if you so wanted to!<
          @ The sky is the limit with this one, and it's one of the essential tools provided to you
           with XVNML2U.{jump_to::"P3-XVNML2U-UnityComponents-Main"}<

          ["P3-XVNML2U-UnityComponents-XVNMLPromptControl"]
          @ The XVNMLPromptControl Componenet makes use of any lines with an Interrogative Role.<
          @ For every text surrounded by parentheses and followed with a {tag_end}, it'll take the array
           of data, and turn them into buttons for the player to press on.<
          @ When you selected a prompt, the response value is the index of that response.<
          @ XVNML then knows the starting point after answering that prompt, as well as
           the ending point after answering the prompt.<
          @ By default, you can have up to 12 prompts to be viewed simultaneously.<
          @ I don't know why you would want that much, but it's there for you if you want to have that many.<
          @ A nice trick to use with Prompts is combining Named Lines with the {paren}jump_to{paren_end}
           macro.<
          @ Honestly, this will be a lot easier on the XVNML parser, because it reduces the amount of nesting.<
          @ The bigger the nesting, the more XVNML will have to work to resolve the starting and ending points
           of those dialogue.<
          @ The XVNMLEssentials.main.xvnml file exemplifies this greatly, showing how after selecting a
           choice, it jumps to whatever label you want that response to go to.<
          @ It also makes your XVNML document a lot nicer.<
          @ Of course, you can type out your document however you want.<
          @ If it's easier branching prompts in, then you can do it.<
          @ Otherwise, make use of Named Lines and the {paren}jump_to{paren_end} macro for
           nicer looking mark-up.{jump_to::"P3-XVNML2U-UnityComponents-Main"}<

          ["P3-XVNML2U-UnityComponents-ResponseControl"]
          @ The ResponseControl Component is a component that must be a child of the gameObject with the
           XVNMLPromptControl component.<
          @ This component receives information grabbed from the XVNMLPromptControl component, and displays
           its content to the user.<
          @ It also allows the user to response with the prompt given to them.<
          @ There are 12 gameObjects with this components, and receiving all information from the
           XVNMLPromptControl componenent.<
          @ That's about it really.{jump_to::"P3-XVNML2U-UnityComponents-Main"}<

          ["P3-XVNML2U-UnityComponents-XVNMLAudioController"]
          @ The AudioController Component is a component that handles the majoring of sounds that
           play from your XVNML file.<
          @ The sounds that play on the XVNMLAudioController is seperate from the audio that's
           played from a cast member.<
          @ Using Unity-Specific macros such as "set_sound", "set_volume"
           and "play_sound"...<
          @ You can set the mood in combination with the XVNMLStage Component.<
          @ {use_scene::"OutsideOfSchool"}Let's cue our scene here...<
          @ And play some peaceful music...{$_doAudioControllerDemonstration} and there we go.<
          @ This is what the XVNMLAudioController is responsible for.<
          @Hana>Happy>Wow {cue_cast::("Hana","Center")|react::"Jump"} That's right!<
          @*>Smile And what you heard just now is handled by the
           CastController instead...<
          @*>Happy That's because it allows anyone to adjust settings for
           SFX, Music, or Voices.<
          @ Yep.<
          @ We honestly could of opted for having Voices defined upon initiation of the
           XVNMLAudioController...<
          @ But how the AudioSources are referenced from a Cast is completely different from
           just playing an SFX or music.<
          @ Which is why we seperated Voices to the CastController...<
          @ Since it maps out a cast and their corresponding portraits and voices...<
          @ from the XVNMLAudioController, which does all the worldly, environmental stuff.
          {jump_to::"P3-XVNML2U-UnityComponents-Main"}<

          ["P3-XVNML2U-UnityComponents-Complete"]
          @ As you see{delay::500}, there are a lot of features and tools at your disposal...<
          @ that isn't just exclusive to what powers XVNML to work in the first place.<
          @ XVNML2U will take the different tools provided by the XVNML binary to assure
           that the development process runs smooth...<
          @ Smooooooooth like butter!<
          @ Of course, there are a lot of other components that are provided with XVNML2U.<
          @ However, you would just have to look at the documentation for that one.<
          @ We just wanted to mention the more...<
          @ "significant" components that you'll find within XVNML2U.<
          @ The information that we gave to you today should be enough for you to get
           started on your own...<
          @ and to also have a better understanding of how everything works.<
          @ Seriously{pause}, I can't stress this enough!<
          @ XVNML2U is a SUPER POWER for story-tellers of all facets of life.<
          @ It truly is amazing, and we hope that you find it just as amazing as well.
          {$_main}<

          #//endregion

          #//Integrate XVNML Manually

          ["P4"]
          @ Oooooooooooooooooooooo!<
          @ So you would like to get "hands-onsie" with XVNML?<
          @ We like your attitude my friend!<
          @ The XVNML binary that's integrated with XVNML2U gives you all sorts of
           utilities that allows you to do more with XVNML.<
          @ In all honesty, despite that this is being ran by the XVNMLDialogueControl
           component...<
          @ {paren}which in turn uses the DialogueWriter static class to power it{paren_end}...<
          @ You actually don't need to use it at all!<
          @ You can access the elements and their respective data once you've created your
           XVNMLObj instance.<
          @ What's the XVNMLObj you may ask?<
          @ Well my friend, that's the class representation of your XVNML file.<
          @ And that's exactly what happens with the XVNMLModule component.<
          @ It takes in a file, it undergoes the tokenizing and parsing process of the document...<
          @ and returns to you an XVNMLObj instance.<
          @ With it, you can traverse, read, and manipulate data with that object.<
          @ Treat it exactly how you would with HTML and JavaScript.<
          @ But instead with XVNML and C#.<
          @ That's how easy it is.<
          @ If you think how the XVNMLDialogueControl runs isn't much to your liking...<
          @ You can always create your own that's more performant, more intuitive, and more
           convenient for you and your Dev Team!<
          @ We want to give power to the people, because that how amazing things are created.<
          @ We would never want to hold you or your Team back from achieving your goals.<
          @ So we made XVNML and XVNML2U as flexible and customizable as possible.<
          @ Of course, you'll have to learn a little bit on it, but other than that, you
           can do whatever you want!<
          @ Every XVNMLObj will have what's called a Root.<
          @ This Root can either be a Proxy tag or a Source tag in your XVNML file.<
          @ And within those tags are all the possible elements that you put inside.<
          @ To traverse and find those tags, there's a few ways that you can do that.<
          @ The most common approach is by using the GetElement generic method.<
          @ All you need to do is specify the tag type you want to find.<
          @ You have an option to put a name, or an index, and the XVNMLObj will find
           that specific tag accordingly.<
          @ So if you have to find a specific set of dialogue within the file...<
          @ Use the GetElement method, with "Dialogue" as "T"...<
          @ And pass in the name through the method's parameter.<
          @ If it finds it, it'll return that type, as well as all of it's data with it for use.<
          @ If it doesn't, it'll just return to you "null"<
          @ You can then do some null-checks to make sure that you get the data that you want,
           and to prevent problems down the line.<
          @ Of course, we must warn you...<
          @ XVNML is indeed a "Mark-Up Language"...<
          @ So you must check that the tag that you are looking for is spelled exactly how it is in
           the document.<
          @ Which can be tedious, but you'll get the hang of it.<
          @ However, if you ever need to add elements to your XVNMLObj...<
          @ That{$_think}{delay::1000} is a feature that's not avaliable yet...<
          @ At least at the time of publishing this version of XVNML2U on the Unity
           Marketplace.<
          @ In the future, we'll be able to add elements to an already generated XVNMLObj...<
          @ And even override existing tags within the document.<
          @ But at this point, we don't see why we would necessarily do that.<
          @ I could be wrong on that.<
          @ If anything, we'll put that on the backburner.<
          @ And if demand ask for it, and is loud enough {paren}in a polite and dignified manner{paren_end}...<
          @ Then we may consider adding that feature on to XVNML.<
          @ Then again...{pause} XVNML IS OPEN SOURCE!<
          @ That means your contribution will matter in the making of XVNML.<
          @ Don't think we're creating this thing on our own...<
          @ The more, the merrier!<
          @ You can look up XVNML on Github, and be a contributer to its development!<
          @ If we never get to the feature that you want us to implement...<
          @ Well, come join us, and PROVE US WRONG!<
          @ That's how we grow and learn as a society...<
          @ We think...<
          @ There's one guy typing out all of this dialogue, and he honestly doesn't know.<
          @ But seriously, consider being a contributer, and make XVNML BETTER THAN EVER!!!<
          @ For any advance topics on integrating XVNML on your own...<
          @ It entirely depends.<
          @ If you plan on using the DialogueWriter for anything...<
          @ then you would need to know about the different callbacks that it has...<
          @ Like when a line starts, when a substring is updated, when a cast expression or voice changes...<
          @ You would have to set up whatever you need to get your project up and running.<
          @ That'll be a lot to cover in a Visual Novel setting, so...<
          @ We advise to look at the documentation either online, or within the XVNML2U package.<
          @ Manual set up is easy, and there isn't anything much else.<
          @ Though there is the static Tokenizer class... We're...{delay::500} sort of debating whether or
           not to make that an avaiable tool for people who what to do advance stuff...<
          ? What do you think?>>
          (
               ("I say make it available!")>
                    @ Hmmmmmmmmmmmmmmmmmmmmmmm...<
                    @ I suppose.<
                    @ Though honestly, all it really does is receives a string as an
                     input, and convert it into a list of Tokens.<
                    @ With it, you may even be able to create your own scripting language within
                     XVNML with the custom tag that you created...<
                    ? However, I think it's best to leave that luxury to the GitHub Contributors.>>
                    (
                         ("What?! No way?!")>
                         @ Yesssss....<
                         @ {sts::100}WAYYYYYYYYYYYYYYYYYYYYYYY!<<
                    )
                    @ {$_defaultTextSpeed} But I digress.<
                    @ Again, we'll see if demand ask for it.<
                    @ We'll talk it over and decide whether it's something that
                     would actually benefit someone using our tool.<
                    @ Honestly, no one would even think about making a scripting language.<
                    @ Everything you need is already provided in XVNML2U!<<

               ("It's best to leave it.")>
                    @ Very smart.<
                    @ We honestly don't see why we would make it public
                     in the first place.<
                    @ However, we feel that it may come as an extra benefit for
                     people needing to evaluate strings and figure out what to do with them...<
                    @ Without the need for comparing single characters to determine what to do.<
                    @ Honestly, it may come it handy for people with a stellar mind.<
                    @ But until the day that an angry mob come slamming at our door...<
                    @ We'll just leave it where it is.<<
                    
               ("I don't know. What it do?")>
                    @ All it really does is receives a string as an
                     input, and convert it into a list of Tokens.<
                    @ There's not much to it really.<
                    @ You have an option to read from a file and tokenize it...<
                    @ Or simply do it locally {paren}a.k.a: within your script{paren_end}<
                    @ Unless demand asks for something like that, we don't see why we
                     should make it public.<
                    @ Again, prove us wrong.<<
          )
          @ With that said, there's a couple of things to keep in mind to make sure
           you have an easier time with integrating XVNML to you project.<
          @ Firstly, you must include ".xvnml" and ".json" as addition extensions
           to include into your Unity Project.<
          @ In fact, that's how the XVNMLAsset is able to manifest into the project,
           and even work when you create a build of your project.<
          @ This step is important.<
          @ Luckily, if the ".xvnml" extension isn't included into the additional extensions
           for Unity to be mindful of...<
          @ XVNML2U will actually include it upon detection {paren}or lack there of...{paren_end}.<
          @ It will also include the ".json" extension so that you can take advantage of
           XVNMLObj data that's been cached...<
          @ which will skip the build process and grab the information from your file's
           corresponding "cache.json" file.<
          @ Yes. That is a feature.<
          @ So if you find that your XVNML files or dialogue isn't being ran or accessed...<
          @ Go to your Project Settings, click on "Editor"...<
          @ And under "C# Project Generation", add the necessary extension to the
           "Addition extensions to include" field.<
          @ That should hopefully do the trick.
          {$_main}<
          
          #//endregion

          #//Some Best Practics     
          ["P5"]
          @ {$_defaultTextSpeed}XVNML is a very, very young mark-up language.<
          @ So, there isn't any "Official" standardized best practices to be mindful of...<
          @ The only person that would know that is {b}the person writing all of this dialogue!{bed}<
          @ With that said{$_think} here are {col::"yellow"|b}several best practices to keep in mind...{bed|coled}<

          ["P5-BestPractices-Start"]
          @ {b|insert::"1"|paren_end|load_prop::("BestPracticesItem1", "Center", "Center")|delay::750}
          Separate your XVNML files as much as you can.{bed}<
          @ This will just make it so you don't have to deal with a lot of text in one file.<
          @ Also, it would make it a lot easier for the Tokenizer and Parser if there isn't
           too much text in one file.<
          @ This will also help with readability, and if you need to check something...<
          @ you'll always know where it is.<
          @ You can even try seperating dialogue into their individual files.<
          @ Whatever make things a lot easier for your Dev Team...<
          @ {
               $_switchToPropFadeOutMode
               |clear_prop::"BestPracticesItem1"
               |$_switchToPropFadeInMode
               |pass}<
          @ Since we're on the topic of seperating files...<
          @ {b|insert::"2"|paren_end|set_prop_scale::(12i, 5i)|load_prop::("BestPracticesItem2", "Center", "Center")|delay::750}
          Name your files based on its Root tag.{bed}<
          @ This just makes things easier differentiating between what's the "Main" XVNML
           file...<
          @ And what are "Source" files.<
          @ {
               $_switchToPropFadeOutMode
               |clear_prop::"BestPracticesItem2"
               |$_switchToPropFadeInMode
               |pass}<
          @ A common naming convention you might see for the file that's being build
           is ending the file name with ".main.xvnml".<
          @ You could also have it as ".proxy.xvnml", knowing that there's a Proxy tag
           as the root tag.<
          @ However, we've stuck with ".main.xvnml", because everyone know what "main" means.<
          @ Seeing the word "main", you can create an association with that file being the
           "Entry Point" of every XVNML source file.<
          @ For example, we named this file "XVNMLEssentials.main.xvnml", because this
           file will be the one to be build first.<
          @ Any other file that needs to be build {paren}that being XVNML source files{paren_end}
           everything will be built and resolved accordingly.<
          @ As for the naming conventions of source files, there's a list of what you can name them.<
          @ You may want to have the name end with ".source.xvnml" or ".src.xvnml"...<
          @ But how would you know what it's a source of?<
          @ That's why we recommend substituting ".source" or ".src" with the tag your are
           sourcing from.<
          @ For example, if you want to source a cast from within your Main XVNML file...<
          @ The file name may be seen as "Cassie.cast.xvnml"...<
          @ Or "Roger.cast.xvnml".<
          @ Same goes for sourcing and embedding dialogue to your Main XVNML File.<
          @ You may see it as "MyFirstDialogue.dialogue.xvnml".<
          @ This way, you know exactly what kind of source file it is.<
          @ A very important note to add...<
          @ You may had noticed some other directories relative to this file...<
          @ Such as "Audio", "Casts", "Images", and "Scenes"...<
          @ This is because when finding a source, it's mapped to the directory of the same
          kind of source that's relative to the Main XVNML file.<
          @ It's a little extra, but you can configure how everything is mapped out
          though I wouldn't recommend it.<
          @ This is because it helps organizes your files, as well as limit the amount of
          times you have to put in an Absolute path.<
          @ By default, by assigning the "src" parameter of a tag to a file path...<
          @ The path mode is Relative by default.<
          @ If you want to state specifically where to find it, you can change the
          path mode to Absolute by typing "pathMode::Absolute".<
          @ Pretty simple.<
          @ And if you don't want it to look into directories relative to your main
          simply have your "src" path start with {quot}..{slash}{quot}<
          @ The Proxy will then look at the same level as your Main XVNML file.<
          @ Again, I wouldn't recommend it due to structure and consistency sake.<
          @ With XVNML, a modular approach to building your XVNML "front-end"
          {space|paren}I guess you could call it{paren_end}...<
          @ Is amongst the most important best practices for not just XVNML...<
          @ but for C{hash} as well.<
          @ {b|insert::"3"|paren_end|delay::750} If you can, limit as much macros as you can.<
          @ Macros is one of XVNML's coolest features.<
          @ However, the unnecessary use of them may lead to the Tokenizer and Parser struggling.<
          @ As of typing this, we haven't had any performance issues with the process.<
          @ In fact, we did, and we fixed it because it was something we didn't want in the final product.<
          @ Image,{delay::500} waiting {bold|color::"yellow"}27 seconds{color_end|bold_end} upon clicking on the "Play Mode" button for Unity to actually start playing...<
          @ Yeah{$_think} Unbelievable.{delay::500} We know.<
          @ This is because the Tokenizer has a list of all tokens that makes up a file.<
          @ Other parts of the building process uses it, and even borrows some tokens...<
          @ from other parts of the process.<
          @ However, analyzing a Skriptr line {paren}as of releasing this version of XVNML2U{paren_end},
           needs to be very specific with the tokens that it gets.<
          @ By default, a Skriptr Line is tokenized as the full line!<
          @ This helps limit the count of defined tokens from being above{$_think}<
          @ I don't know...<
          @ 18000{plus} tokens that needs to be iterated over.<
          @ And that takes up a lot of performance.<
          @ So the Tokenizer has the option to "simplify", or to "complicate".<
          @ And for parsing the actual Skriptr Line to further figure out what it's suppose to do...<
          @ the tokenizer is then "complicated".<
          @ By doing this, we made the building process of the XVNMLObj almost instantaneous.<
          @ But we also advised seperating files so that it doesn't iterate through 18000{plus} tokens.<
          @ It's basically chopped up and borrowed from other parts of the process, making it
           far more effecient.<
          @ You honestly don't have to worry about it too much.<
          @ Just be sure you keep all this in mind when creating your story.<
          @ Before we conclude...<
          ? Would you like to go over those points again?>>
          (
               ("No")>
                    @ Alrighty!<<
               ("Yes")>
                    @ {jump_to::"P5-BestPractices-Start"}<<
          )

          @ Be sure the balance the amount of macros used verses the amount of Skriptr lines that
           needs to be parsed.<
          @ And hopefully your XVNML file will {b}become a lot more optimized{bed}.
          {$_main}<

          #//endregion

          #//End Demo

          ["CL"]
          @ {$_defaultTextSpeed}We hope that you've enjoyed this demo.<
          @ Please consider loading the other Unity Scenes to
           get a more in-depth explanation on the different tools and features
           that XVNML and XVNML2U can provide.<
          @ With that said, logging out!<<

          #//endregion
     </dialogue>
</source>