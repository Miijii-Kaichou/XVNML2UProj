<proxy name::"XVNMLEssentials.Main.XVNML" lang::"CSharp" engine::"Unity">
     <metadata name::"_metadata">
          <title name::"XVNMLEssentials"/>
          <date value::"06/25/2023"/>
          <copyright year::2023 owner::"Enjyoii"/>
     </metadata>

     <castDefinitions>
          <cast name::"Hana" src::"Hana\Hana.cast.xvnml"/>
     </castDefinitions>

     <sceneDefinitions>
          <scene name::"OutsideOfSchool" src::"School\OutsideOfSchool.scene.xvnml"/>
     </sceneDefinitions>

     <keycodeDefinitions name::"_globalInputDef">
          <keycode name::"_proceedWithMouse"     vkey::LeftMouse      purpose::PROCEED/>
          <keycode name::"_proceedWithEnter"     vkey::Return         purpose::PROCEED/>
          <keycode name::"_navUp"                vkey::Up             purpose::NAVIGATION_UP/>
          <keycode name::"_navDown"              vkey::Down           purpose::NAVIGATION_DOWN/>
          <keycode name::"_navLeft"              vkey::Left           purpose::NAVIGATION_LEFT/>
          <keycode name::"_navRight"             vkey::Right          purpose::NAVIGATION_RIGHT/>
     </keycodeDefinitions>

     <dialogue name::"XVNML2U Sample" #textSpeedControlledExternally>
          @ {set_text_speed::40}Welcome to XVNML2U!{jump_to::"Test"}<
          @ This package demonstrates the capabilities in which the XVNML 
          Class Library is capable of{delay::500|clr}when used with the Unity Game Engine.<
          @ What you see here{delay::750} is a normal dialogue.<
          @ And {insert::"THIS"|delay::1000} is a dialogue with {set_text_speed::60} a 
          looooooooooooooooooooooooooooooooooooooooooooooooooooot of {set_text_speed::30}charisma!!!!<
          @ {set_text_speed::40}And with a normal XVNML Dialogue Control component, you can run whatever 
          dialogue you want.<
          @ This is just a sample of what XVNML can do.<
          @ XVNML is a powerful tool with an EMPHASIS in story telling.<
          @ And we're starting our journey off by integrating XVNML to Unity 
          {paren}hence "XVNML2U"{paren_end}.<
          @ We're very excited to see how you'll put this tool to the ultimate test.<
          ?  What's boning on?>>
          (
               ("Nothing")>
                    @  I see.<<
          )
          
          #//Main Menu

               ["Main-FirstTime"]
               ? So, what would you like to know about XVNML or about XVNLM2U?{pause|hide_text_box}>>
               (
                    ("What is XVNML?")>
                         @ {show_text_box|jump_to::"P1"|pass}<<
                    ("Why XVNML?")>
                         @ {show_text_box|jump_to::"P2"|pass}<<
                    ("What is XVNML2U...")>
                         @ {show_text_box|jump_to::"P3"|pass}<<
                    ("Integrate XVNML Manually...")>
                         @ {show_text_box|jump_to::"P4"|pass}<<
                    ("Some Best Practices...")>
                         @ {show_text_box|jump_to::"P5"|pass}<<
               )

               ["Main"]
               @ And with that said...<
               ? Is there anything else you would like to know?{pause|hide_text_box}>>
               (
                    ("What is XVNML?")>
                         @ {show_text_box|jump_to::"P1"|pass}<<
                    ("Why XVNML?")>
                         @ {show_text_box|jump_to::"P2"|pass}<<
                    ("What is XVNML2U...")>
                         @ {show_text_box|jump_to::"P3"|pass}<<
                    ("Integrate XVNML Manually...")>
                         @ {show_text_box|jump_to::"P4"|pass}<<
                    ("Some Best Practices...")>
                         @ {show_text_box|jump_to::"P5"|pass}<<
                    ("End Demo")>
                         @ {show_text_box|jump_to::"CL"|pass}<<
               )
               
          #//endregion

          #//What is XVNML

               ["P1"]
               @ {set_text_speed::40}XVNML stands for 
               {quot}X-Tensible Visual Novel Mark-Up Language.{quot}<
               @ It takes the usual format that people are used to when 
               storing dialogue data, and caters it towards those making visual novels.<
               @ Despite having {quot}Visual Novel{quot} in the name as well as stating 
               that it caters towards those making them, you can use it outside the realm 
               of an actual visual novel.<
               @ All that it is used for is to create story-centric content a lot more 
               intuitive.<
               @ We've originally created a precursor to XVNML called DSL {paren}Dialogue Scripting Language{paren_end} 
               and it's code-base was very fragile, inaccurate, slow, and unreliable.<
               @ So we took the features from DSL, and made it better, making it more like HTML.<
               ? It also provides a syntax language called Skriptr, which is how you'll mainly be 
               typing out dialogue.>>
               (
                    ("Skriptr? What is that?")>
                    @ {jump_to::"P1-Skriptr"|pass}<<
               )

               ["P1-Skriptr-Incorrect"]
               @ {set_text_speed::40}Unfortunately, that's not the correct answer...
               {jump_to::"P1-Skriptr-CorrectAnswer"}<

               ["P1-Skriptr"]
               @ {set_text_speed::40}Skriptr is the syntaxical language used in tandem with XVNML to...<
               @ type out dialogue.<
               @ Each Skriptr line must first be given a role to play.<
               @ It can either take in a Declarative Role {paren}denoted by the {quot|at|quot} symbol{paren_end}...<
               @ Or a Interrogative Role {paren}denoted by the {quot|qm|quot} symbol {paren_end}...<
               @ When given a Declarative Role, it'll type out dialogue to the screen as normal...{delay::500|clr}
               Just like what you are seeing now.<
               @ However, if given a Interrogative Role...<
               @ The dialogue acts as a Prompt in which the user must answer to.<
               ? For example, how many states does the United States have?>>
               (
                    ("50")>
                         @ That is correct!<<
                    ("13")>
                         @ {jump_to::"P1-Skriptr-Incorrect"|pass}<<
                    ("3")>
                         @ {jump_to::"P1-Skriptr-Incorrect"|pass}<<
                    ("I honestly don't know...")>
                         @ That's okay if you don't know.<<
               )

               ["P1-Skriptr-CorrectAnswer"]
               @ {set_text_speed::40}There are 50 states that makes up the United States of America.<
               @ Awesome huh?<
               @ Let's take a look at the file where we have all of this dialogue.<
               @ And don't freak out when you look at it.<
               @ I promise you, you'll understand it faster than I can finish this sentence.<
               @ Search up and find a file called {quot}XVNMLEssentials.main.xvnml{quot}.<
               @ Open that in VSCode and go to Line 61.<
               @ You will see that that's the first thing that we started off with.<
               @ And if you jump to Line 120, you'll exactly what I'm currently saying.<
               @ You notice that it's just the {quot|at|quot} symbol when stating a 
               Declarative Role on a Skriptr line.<
               @ However, if you've defined Cast members within your XVNML project...<
               @ You can set them as a speaker!<
               @ {
                    set_cast_motion::"Interpolation"|
                    set_cast_motion_duration::0.5f|
                    cast_enters_from::"Left"
               }For example...<
               @??? {cue_cast::("Hana","Center")}Hello!<
               @??? My name is Hana!<
               @Hana>Happy {react::"Jump"}It's very nice to meet you!<
               @ Anything after and before actual dialogue is known as the Cast Signature.<
               @ {exp::("Hana", "Smile")|react::("Hana", "Jump")}If you look at Line 121, this is considered a Normal Cast Signature.<
               @ It's the most common signature that you'll see inside an XVNML document.<
               @ Anything without a name is considered a Narrative Cast Signature.<
               @ As the name suggests, it's meant to denote that the Narrator is speaking.<
               @??? If there's a {quot|qm|qm|qm|quot} in place of the name...<
               @??? This is known as the Anonymous Cast Signature.<
               @* And anything with an {quot|aster|quot} is consider a Persistent Cast Signature.<
               @ The general format of a Cast Signature is the following...<
               @ {paren}{at}{pipe}{qm}{paren_end}{tag_end}{brack}Expressions{brack_end}{tag_end}{brack}Voice{brack_end}<
               @ {move_cast::("Hana",-1325)}It's definitely a lot to keep up with, but that's what the XVNMLEssentials guide is for...<
               @ To help you get in touch with XVNML.<
               ? Would you like to know more about Cast Signatures?>>
               (
                    ("Yes")>
                         @ {pass}<<
                    ("No")>
                         @ That's alright.<
                         @ You have sample files to look over and study.<
                         @ However, if you need more context for something, or understanding...<
                         @ You can always look at the documentation that comes with XVNML2U...<
                         @ As it goes more in-depth with how to work with XVNML.
                         {jump_to::"Main"}<<
               )

               ["P1-Skriptr-CastSignatures-Main-FirstTime"]
               ? {set_text_speed::40}Which Cast Signature would you like to know about?>>
               (
                    ("Narrative Cast Signatures...")>
                         @ {jump_to::"P1-Skriptr-CastSignatures-Narrative"|pass}<<
                    ("Normal Cast Signatures...")>
                         @ {jump_to::"P1-Skriptr-CastSignatures-Normal"|pass}<<
                    ("Persistent Cast Signatures...")>
                         @ {jump_to::"P1-Skriptr-CastSignatures-Persistent"|pass}<<
                    ("Anonymous Cast Signatures...")>
                         @ {jump_to::"P1-Skriptr-CastSignatures-Anonymous"|pass}<<
               )

               ["P1-Skriptr-CastSignatures-Main"]
               ? {set_text_speed::40}Which Cast Signature would you like to know about?>>
               (
                    ("Narrative Cast Signatures...")>
                         @ {jump_to::"P1-Skriptr-CastSignatures-Narrative"|pass}<<
                    ("Normal Cast Signatures...")>
                         @ {jump_to::"P1-Skriptr-CastSignatures-Normal"|pass}<<
                    ("Persistent Cast Signatures...")>
                         @ {jump_to::"P1-Skriptr-CastSignatures-Persistent"|pass}<<
                    ("Anonymous Cast Signatures...")>
                         @ {jump_to::"P1-Skriptr-CastSignatures-Anonymous"|pass}<<
                    ("I've learned everything there is to know about Cast Signatures...")>
                         @ That's great to hear!
                         {jump_to::"P1-Skriptr-CastSignatures-Complete"}<<
               )

               ["P1-Skriptr-CastSignatures-Narrative"]
               @ {set_text_speed::40}A Narrative Cast Signature denote that the narrator is 
               speaking.<
               @ You can not set an expression for the narrative...<
               @ But you can set a voice.<
               @ We don't have a voice set up for the narrator though...<
               @ But that is the only valid syntax that it has.<
               @ There is a hidden benefit of just using a Narrative Cast Signature.<
               @ And that is if you just want to execute macros alone.<
               @ When doing so, a macro to keep in mind is the {quot}pass{quot} macro.<
               @ This macro simpily bypasses user input, and will immediately go to the{space}
               next SkriptrLine.<
               @ So any macros that does some form of configuration or setup...<
               @ You would use the Narrative Cast Signature, and create your Macro Invocation Block.<
               @ To invoke more than one macro, you would seperate each invocation with {quot}{pipe}{quot}.<
               @ It's a hidden benefit of the Narrative Cast Signature significant enough to be mentioned...<
               @ Because even the XVNML file being used to display all of this uses this method from{space}
               time to time.<
               @ Never forget to add the {quot}pass{quot} macro after all prior macro invocations.<
               @ Or you will be presented with a empty dialogue box, waiting for you to send an input.<
               @ That is unless you have the {quot}{hash}dontDetain{quot} flag set.{jump_to::"P1-Skriptr-CastSignatures-Main"}<
               
               ["P1-Skriptr-CastSignatures-Normal"]
               @ {set_text_speed::40}A Normal Cast Signature denotes that a character is speaking.<
               @Jimmy You can put whatever name in here...<
               @* However, if that cast was not defined, you can't using expressions{space}
               or voices.<
               @Hana {cue_cast::"Center"}However for me, I am a defined Cast member!<
               @*>Happy I can change expressions {paren}as you saw earlier...{paren_end}<
               @*>V::Wow And I can play a voice based on the how the Normal Cast{space}
               signature is formed.<
               @ {exp::("Hana","Smile")}Nice work, Hana. I'm really{exp::("Hana","Happy")|react::("Hana","Jump")} proud of you.<
               @Hana Hehe!<
               @ {move_cast::("Hana",-1325)}An added bonus to Normal Cast Signatures comes with the{space}
               different Cast-Specific Macros exclusive to Unity...<
               @ Such as "move_cast", "cue_cast", "cast_enters_from", "set_cast_motion", and "set_cast_motion_duration".<
               @ In fact, we happened to use those macros just demonstrating how Normal Cast Definitions work.<
               @ You'll soon realize that you can do a lot of cool stuff with XVNML2U.<
               @ For example, Cast Reactions {paren}which we had used about 3 times so far{paren_end}.<
               @ Last thing that is nice to know about Normal Cast Signatures is that by default...<
               @ It follows the "Role{tag_end}Name{tag_end}Expression{tag_end}Voice" format.<
               @ However, you can omit either an expression or a voice.<
               @ To omit a voice, just name the cast expressions as normal.<
               @ To omit an expression, use the "V{colon|colon}" prefix, followed by the voice name.<
               @ You can even change the order from Expression{tag_end}Voice to Voice{tag_end}Expression!<
               @ You just need to make sure that an Expression Prefix {paren}E{colon|colon}{paren_end}{space}
               and a {paren}V{colon|colon}{paren_end} before the expression name and voice name{space}
               respectively.
               {jump_to::"P1-Skriptr-CastSignatures-Main"}<
               
               ["P1-Skriptr-CastSignatures-Persistent"]
               @ {set_text_speed::40}A Persistent Cast Signature takes the last cast member to speak, and{space}
               carries them over.<
               @ The keywords here is {quot}last cast member{quot}.<
               @ Persistent Casts doesn't work if the previous speaker was{space}
               Narrative or Anonymous.<
               @ So the last Normal Cast Signature specified prior to using a{space}
               Persistent Cast Signature...<
               @ Will denote that the cast is still speaking.<
               @ And because of this, you can treat Persistent Cast Signatures as a{space}
               short-cut to Normal Cast Signatures.<
               @ You just don't have to type the name out {paren}which is the core reasoning{space}
               for having a Persistent Cast Signature{paren_end}.<
               @ You can set the Expressions and Voices of the previous mentioned cast{space}
               as normal.
               {jump_to::"P1-Skriptr-CastSignatures-Main"}<
               
               ["P1-Skriptr-CastSignatures-Anonymous"]
               @ {set_text_speed::40}An Anonymous Cast Signature denotes that the speaker is unknown.<
               @ You really can't do much with an Anonymous Cast Signature.<
               @ However, by combining macros, you can set a cast on to the screen{space}
               and still change their expressions and voices.<
               @ You would have to do that until you switch to the Normal Cast Signature{space}
               on the next line.<
               @  If you have checked out Persistent Cast Signatures, you've learned that{space}
               an Anonymous Cast Signature has no persistency.<
               @ So, you'll have to keep on typing {quot|qm|qm|qm|quot} until{space}
               the speaker is known to the player.
               {jump_to::"P1-Skriptr-CastSignatures-Main"}<
               
               ["P1-Skriptr-CastSignatures-Complete"]
               @ {set_text_speed::40}It's definitely a lot, huh?<
               @ You can always look back into {quot}XVNMLEssentials.main.xvnml{quot|space}
               to get a feel of how Skriptr works.<
               @ One last thing to cover before we conclude is that you can{space}
               name a SkriptrLine.<
               @ Named Skriptr Lines enables you to control the flow of dialogue.<
               @ You might of seen it in the previously mentioned file.<
               @ You may have also seen words in curly braces.<
               @ That is what's known as a Macro Invocation Block.<
               @ And words like {quot}quot{quot}, {quot}jump_to{quot}, {quot}space{quot}...<
               @ Those are macros, and they have established an endpoint to a method call.<
               @ You'll learn more about Macros once you've opened the {quot}MacroLibraries{quot} scene.<
               @ But you can use the {quot}jump_to{quot} macro call and specify a name.<
               @ Sadly, if you need to check a condition before making a jump, the macro would have to{space}
               be created manually...<
               @ Or you would have to use some code-behind to achieve that.<
               @ For now, that's all we have to cover for Skriptr.<

               ["P1-Tags"]    
               @ {set_text_speed::40}The last thing that we need to mention for XVNML is Tags.<
               @ Since XVNML is a mark-up language, it'll be closely related{space}
               to something like HTML or XML.<
               @ However, there's a couple of features that every tag has.<
               @ To address the elephant in the room...<
               @ The {tag}dialogue{tag_end} tag is very unique.<
               @ There are no tags that can make the {tag}dialogue{tag_end} as{space}
               its parent tag.<
               @ You can try, but the Skriptr Parser will mess up...<
               @ Causing all sorts of havoc.<
               @ And...
               {delay::1000}
               {insert::"Ha"|delay::500}
               {insert::"ha"|delay::500}
               {insert::"ha"|delay::500}
               ...
               {pause|clr}
               We don't want that, now do we?<
               @ With that said, every tag will have 3 default parameter...<
               @ the {quot}name{quot} parameter...<
               @ the {quot}id{quot} parameter...<
               @ and the {quot}altName{quot} parameter.<
               @ And there are also another type of parameter known as a Flag Parameter.<
               @ You may encounter some as you learn XVNML...<
               @ They will always have a {hash} prior to a name.<
               @ A very handy flag that you can use for dialogues is called {quot}{hash}dontDetain{quot}<
               @ This will automatically have all dialouge bypass human input...<
               @ And will continue to the next line of dialogue.<
               @ You can even set a {quot}detainPassDelay{quot} value, which will wait for{space}
               a set amount of milliseconds before doing the bypass.<
               @ And finally, with the {quot}{hash}allowInputOnDetainPassDelay{quot} allows{space}
               the player to send input until after the time set by the...<
               @ {quot}detainPassDelay{quot} elapsed.<
               @ Very handy stuff, huh?<
               @ There will be a .pdf file in the {quot}documentations{quot} folder.<
               @ In that will list all valid parameters and flags for each tag.<
               @ You can also find a list of macros and their required arguments...<
               @ learn how to create Custom Macros and attaching their endpoints...<
               @ AND...{delay::1000} how to create Custom Tags!<
               @ That's right, you can define your own tags.<
               @ The documentation has all of that information checked.<
               @ Be sure to read it thoroughly.<
               @ You'll soon realize that you can do a whole lot with XVNML{space}
               as you explore more into the XVNML2U package.
               {jump_to::"Main"}<

          #//endregion
     
          #//Why Create XVNML

               ["P2"]
               @ {set_text_speed::40}{quot}Why{quot} is a very good question.<
               @ Primarily because we already have certain tools and 
               packages that makes creating dialogue and providing story-centric...< 
               @ elements to your games very easily.<
               @ However, with XVNML, we took the {quot}common{quot} way of storing 
               dialogue data, and brought it to a level where you can treat an 
               XVNML file like it was a Word document for a screenplay.<
               @ We've also stack different tools and features that makes reading 
               data from this as simple as working with HTML...<
               @ And even if you haven't worked with HTML, it's a very small 
               barrier-of-entry.<
               @ That's why something like XVNML2U exists{semi} to 
               teach you how to type XVNML files, and showcase how 
               to use XVNML to power your dialogue systems.<
               @ XVNML primarily uses Skriptr to type out all of the dialogue.<
               @ Skriptr is made so that people such as those coming from Ren'Py can 
               easily learn and use.<
               @ Besides denoting who the {quot}speaker{quot} is, Skriptr is 
               very different from Ren'Py.<
               @ However in the future, Skriptr would have ungone a numerous 
               amount of changes and updates...<
               @ So perhaps it'll become a little more like Ren'Py later on.<
               @ The benefit for using XVNML part of your game development workflow is 
               the fact that all the content is right in front of you, and 
               is seperate from the Unity Editor.<
               @ No need to create a Scriptable Object that holds all of your 
               dialogue data...<
               @ You don't have to download a Node-Based Visual Language for arranging dialogues and 
               handling events...<
               @ And there's no need to parse a JSON or XML manually...<
               @ And with XVNML2U, the integration has already been done for you, so you 
               can start creating your dream game sooner than later.<
               @ Of course, if anything, you can always get the binary for XVNML and do the integration yourself...<
               @ Allowing you to reduce the amount of bloat that you get from XVNML2U.<
               @ There will be a whole section on how to integrate XVNML into your own projects without 
               the use of XVNML2U.
               {jump_to::"Main"}<

          #//endregion    

          #//What is XVNML2U

               ["P3"]
               @ {set_text_speed::40}XVNML2U...<
               @ Why...{delay::1000|clr}It's this one of course!<
               @ The Unity Package that you are using right now!<
               @ Jokes aside, XVNML2U is a Unity Package that integrates 
               XVNML to create an effective Dialogue System.<
               @ That's about it really, other than with the power of XVNML...<
               @ You can do a lot more with XVNML2U than you can with just reading 
               data from an XVNML file.<
               @ XVNML2U provides you with Unity-Exclusive Tags, Macros, and features 
               outside of native usage of XVNML...<
               @ Such as loading images, using Cast Data to display a character...<
               @ Playing sound effects and background music, integrate a prompt system using 
               SkriptrLine data...<
               @ Just to name a few.<
               @ XVNML2U provides you with basic gameObjects that you can use to your advantage.<
               @ If you just want something basic, with no prompts, image loading or anything...<
               @ Use the BasicModuleKit.<
               @ If you want something more like a Visual Novel, you can use the VNModuleKit.<
               @ There's other important components as well, such as the DialogueProcessAllocator 
               which takes advantage of XVNML's feature of {quot}Concurrent Dialogue Processes{quot}.<
               @ Concurrent Dialogue Processes {paren}or CDP{paren_end} is a fancy way of saying...<
               @ {quot}You can render more than one dialogue on a screen.{quot}<
               @ So, if you ever want to simulate a crowd of people taking in the middle of 
               Town Square...<
               @ You'd utilize CDPs to achieve that.<
               @ However, it's required to have the DialogueProcessAllocator in your scene 
               {paren}or if you are integrating XVNML on your own, something equivalent to it.{paren_end}<
               @ Because it'll allow you to not only run multiple dialogue at once, 
               you can use it to send actions to a target DialogueControl...<
               @ {paren}which is another important component{paren_end}.<
               @ The Dialogue Control {paren}and many other components like it{paren_end}...<
               @ allows you to use UnityEvents to have certain objects to certain things...<
               @ For example, if dialogue starts playing, have the dialogue box fade in...<
               @ And when every line has been said, have the dialogue box fade out on the{space}
               {quot}onFinish{quot} event.<
               @ Another example is when you are using XVNMLTextRenderer component...<
               @ With the OnTextChange event, you can have it make a noise, or use the callback to animate{space}
               TextMeshPro {paren}with whatever TMP effects tool you are using{paren_end}.<
               @ Utilizing these UnityEvents{delay::500}, you can truly give your dialogue personality and PAZZAZ!<
               @ There are other important Unity components that you can benefit from with XVNML2U...<
               @ Such as the XVNMLLogListener, XVNMLActionScheduler, and XVNMLInputManager.<
               ? Would you like to learn more about these components?>>
               (
                    ("Yes")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents"|pass}<<
                    ("No")>
                         @ That is fine<
                         @ You can always look at the documentation for later.<
               )

               ["P3-XVNML2U-UnityComponents-Main-FirstTime"]
               ? {set_text_speed::40}Which component are you interested in learning?>>
               (
                    ("The LogListner Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-LogListener"|pass}<<
                    ("The ActionScheduler Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-ActionScheduler"|pass}<<
                    ("The InputManager Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-InputManager"|pass}<<
                    ("The Stage Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-Stage"|pass}<<
                    ("The SceneController Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-SceneController"|pass}<<
                    ("The CastController Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-CastController"|pass}<<
                    ("The XVNMLPromptControl Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-XVNMLPromptControl"|pass}<<
                    ("The XVNMLAudioController")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-XVNMLAudioController"|pass}<<
                    ("The ResponseControl Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-ResponseControl"|pass}<<
                    ("The Confirm Marker")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-ConfirmMarker"|pass}<<
               )

               ["P3-XVNML2U-UnityComponents-Main"]
               ? {set_text_speed::40}Are there any more components you would like to learn about?>>
               (
                    ("The LogListner Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-LogListener"|pass}<<
                    ("The ActionScheduler Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-ActionScheduler"|pass}<<
                    ("The InputManager Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-InputManager"|pass}<<
                    ("The Stage Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-Stage"|pass}<<
                    ("The SceneController Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-SceneController"|pass}<<
                    ("The CastController Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-CastController"|pass}<<
                    ("The XVNMLPromptControl Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-XVNMLPromptControl"|pass}<<
                    ("The XVNMLAudioController")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-XVNMLAudioController"|pass}<<
                    ("The ResponseControl Component")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-ResponseControl"|pass}<<
                    ("The Confirm Marker")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-ConfirmMarker"|pass}<<
                    ("I have learned enough about XVNML2U components...")>
                         @ {jump_to::"P3-XVNML2U-UnityComponents-Complete"|pass}<<
               )

               ["P3-XVNML2U-UnityComponents-LogListener"]
               @ {set_text_speed::40}The LogListener Component is a very handy component when it comes to receiving internal messages...<
               @ from the XVNML binary.<
               @ From running the tokenizer, to analyzing Tags and Skriptr Lines with the parser...<
               @ to even tags being resolved to their respective types...<
               @ the LogListner Component takes those messages, and allows them to be displayed{space}
               on the Unity Console.<
               @ You can toggle off if you want to receive any logs {paren}because we know{space}
               how annoying it can be being bombarded with messages...{paren_end}<
               @ You can even toggle on and off the different kinds of messages you receive.<
               @ You'll receive either a Verbose message {paren}with not-so important pieces of information{paren_end}...<
               @ Warning messages...<
               @ And of course Error messages.<
               @ If you wanted to, you could have the Editor's PlayMode status as {quot}paused{quot|space}
               every time an error message is received from either...<
               @ The Tokenizer...<
               @ Parser...<
               @ Tags...<
               @ Macro Invocations...<
               @ And much more.<
               @ A really handy component to use, but definitely isn't need.<
               @ It is recommended to have this component within your game scene so that you{space}
               can undergo the proper debugging in your code.<
               @ However, sometimes it could be an issue from our end.<
               @ You can always report the issue on GitHub, stating what you are trying to accomplish...<
               @ The message you are receiving...<
               @ And if it's replicable or not.<
               @ We will review and resolve the issue as promptly as possible...<
               @ To assure that you are using XVNML2U to its fullest.<
               @ Because no one likes to have to deal with errors slowing them down from their progress.<
               @ We know we don't.<
               @ And neither does Hana.
               {jump_to::"P3-XVNML2U-UnityComponents-Main"}<

               ["P3-XVNML2U-UnityComponents-ActionScheduler"]
               @ {set_text_speed::40}The ActionScheduler Component is one of the most important components to have{space}
               within your project.<
               @ It's responsibility is to add pending actions on a queue for it to be properly executed.<
               @ Objects that do send an action to the ActionScheduler usually inherit from the{space}
               MonoActionSender class.<
               @ Without it, you can't extend any functionalities you want to include, since the backend of{space}
               XVNML2U runs on a seperate thread...<
               @ And can not be called on the Unity Thread.<
               @ There are a few exceptions.<
               @ However, if you are implementing your own Macros or Tags...<
               @ And you receive an error message in Unity that you must modify something on the Main Thread{del::500|clr}
               {paren}that being Unity's Thread{paren_end}...<
               @ Try finding a way to incorporate your code using the MonoActionSender class.<
               @ With it, you'll be given the {quot}SendNewAction{quot} method.<
               @ It takes in an anonymous method where it must return a WCResult.<
               @ You can either return an {quot}Ok{quot}{space}{paren}a successful execution{paren_end}...<
               @ an {quot}Unknown{quot}{space}{paren}which it will retry the action{paren_end}...<
               @ or an {quot}Error{quot}{space}{paren}an unsuccessful execution{paren_end}...<
               @ However, this must be noted...<
               @ By return an {quot}Unknown{quot} WCResult, it'll repeat the action until you either receive...<
               @ an {quot}Ok{quot} result, or an {quot}Error{quot} result.<
               @ So use this sparingly{semi} keep it between an {quot}Ok{quot} result...<
               @ and an {quot}Error{quot} result.<
               @ That way, you'll never come across any issues down the line.<
               @ XVNML2U uses the {quot}SendNewAction{quot} method for it's MacroLibrary and within the{space}
               DialogueControl component.<
               @ So having an ActionScheduler within your scene is crucial if you want Unity-Specific Macros{space}
               and Tags to work inside your XVNML file.<
               @ This can especially be said for your own Macros and Tags.<
               @ In the future, we may have it where it's not required to add an ActionScheduler as a component.<
               @ But for now, make it your mission to include this component inside your project.<
               @ Otherwise, any XVNML files that uses those Macros will not invoke.<
               @ The same thing goes with creating your own custom tags.<
               @ However, since you are inheriting from UserDefinedTag, you won't be able to{space}
               use MonoActionSender.<
               @ The solution to that is using the static variant of SendNewAction via the ActionScheduler itself.<
               @ Honestly, you don't have to inherit any of your classes with the MonoActionSender, and opt for{space}
               using the static method variant instead...<
               @ Allowing you to inherit you class a different way.<
               @ Though it's best to use the static method if you really need to.<
               @ If you know your class will be a Unity Component inside your gameObject...<
               @ have it inherit from MonoActionSender.<
               @ Otherwise, switch to using the static variant of that method.
               {jump_to::"P3-XVNML2U-UnityComponents-Main"}<

               ["P3-XVNML2U-UnityComponents-InputManager"]
               @ {set_text_speed::40}The InputManager Component utilized defined keycodes inside your XVNML file.<
               @ This component is also an important one.<
               @ In order to be able to do things like progressing the dialogue...<
               @ you need this component in your Game Scene.<
               @ The event that triggers from signaling an input from you defined keycodes...<
               @ is know as that keycode's {quot}purpose{quot}.<
               @ However, inside XVNML2U, it's called the {quot}InputEvent{quot}.<
               @ Very inconsistent.{delay::750} I know...<
               @ You don't have to rub it in.<
               @ There are pre-defined Purposes or InputEvents that you can put inside your keycode definition...<
               @ Those being PROCEED, SAVE, LOAD, QUICK_SAVE, QUICK_LOAD, PAUSE, RESUME, SHOW_LOG...<
               @ MAIN_MENU, NAVIGATE_LEFT, NAVIGATE_DOWN, NAVIGATE_RIGHT, and NAVIGATE_UP.<
               @ However, you can set up to 32 presets for you {quot}the creator{quot} to use.<
               @ You decide what presets does what, and you can annotate that by using the {quot}description{quot|space}
               tag parameter on the {tag}keycode{tag_end} tag.<
               @ You could even be descriptive by simply using the tags name, making the {quot}description{quot|space}
               parameter an option.<
               @ You can even put more than 1 keycode with the same Purpose{slash}InputEvent...<
               @ Allowing for XVNML2U to accept more than one input.<
               @ So keep that in mind.{jump_to::"P3-XVNML2U-UnityComponents-Main"}<

               ["P3-XVNML2U-UnityComponents-Stage"]
               @ {set_text_speed::40}The Stage Component utilizes defined scenes and cast insider your XVNML file.<
               @ All scenes defined in the {tag}sceneDefinitions{tag_end} tag have a reference to an defined{space}
               image.<
               @ Whether the definitions of those Images are within the Proxy file...<
               @ Or pointing to a Source file.<
               @ The same logic applies for {tag}castDefinitions{tag_end}.<
               @ The data contained in a scene's corresponding image is loaded and converted to a tangible{space}
               Unity Asset at Runtime.<
               @ Once XVNML2U reads those bytes, it'll cache the final produce until it is needed using the{space}
               {quot}cue_scene{quot} Macro.<
               @ At that point, it'll use the information cached, and set the image to be seen in the Game View.<
               @ {cue_scene::"OutsideOfSchool"}Like so.<
               @ You may even set a layer in which the scene will be viewed, allow for a scene made with{space}
               different parts.<
               @ This is all that the SceneController does, and you would have to create your own macro{space}
               to do fancy stuff, such as changing the image's RGBA values.<
               @ {clear_scene}You can unload the scene by using the {quot}clear_scene{quot} macro.<
               @ Without passing an argument, it'll clear the only or last image that was loaded.<
               @ Passing in a value, such as which layer to target {paren}a numerical value{paren_end}{space}
               or by the name of the scene {paren}which the SceneController will find the layer with that image{paren_end}...<
               @ You can remove those specific scenes, or replace them using the {quot}cue_scene{quot} macro{space}
               and override a layer with the new image.<
               @ Again, that's basically the only thing that you can you do with the SceneController.<
               @ However, there will me more functionalities for it in the later versions of XVNML2U to come.<
               @ This isn't so much for Casts however.<
               @ You can cue a cast and set them at a position using the {quot}cue_cast{quot} macro.<
               @ You can either position them using {quot}Left{quot}, {quot}Right{quot}, and {quot}Center{quot}.<
               @ Or by a relative shift using a numerical value.<
               @ You can even specify an offset.<
               @ {
                    set_cast_motion::"Interpolation"|
                    set_cast_motion_duration::0.5f|
                    cast_enters_from::"Left"|
                    cue_cast::("Hana","Center")
               } There are many macros that you can use to influence how your target cast enters the stage.<
               @ {sts::100}You can specify the motion {paren}either Instant or Interpolation{paren_end}...<
               @ The duration that it takes for her to enter the stage {paren}this is if you set her motion as{space}
               Interpolation{paren_end}...<
               @ And you can decide from which side she enters from {paren}Left, Right, or Center{paren}.<
               @Hana>Happy>Wow {react::"Jump"}That's right!<
               @* It may seem a lot, but it's really that simple.<
               @*>Smile So long that you thoroughly read through the documentation...<
               @*>Happy {react::"Jump"}It shouldn't be a problem at all!<
               @ {exp::("Hana"|"Smile")}After cuing a cast member on to the stage, you can move her around{space}
               by using the {quot}move_cast{quot} macro.<
               @ {move_cast::("Hana", -750)}We can move her to the left...<
               @ {move_cast::("Hana", 750)}Move her to the right...<
               @ {move_cast::("Hana", 0)}Put her back in center...<
               @ And we can do the same thing, but this time with Teleportation...{set_cast_motion::"Instant"|set_cast_motion_duration::0f}<
               @Hana {move_cast::-750}I teleport to the left...<
               @*>Happy {move_cast::750}I teleport to the right...<
               @* {move_cast::0}And now I'm back at center stage!<
               @ Pretty mind blowing...{exp::("Hana", "Smile")} We know...<
               @ We really appreciate{exp::("Hana", "Happy")} the demonstration, Hana!<
               @Hana {react::"Jump"}Any time, chief!<
               @ {move_cast::("Hana", -1325)}Basically, the stage is doing exactly what a stage is suppose to do...<
               @ You set up a scene, and cast members can {quot}walk{quot} on stage.<
               @ And you can control the timing of that using the prementioned Macros within you Skriptr lines!<
               @ You would have to memorize some of these macros to get use to them.<
               @ But once you know them, you're basically writing your own Screenplay!<
               @ Astonishing is XVNML2U.<
               @ You can create macros that control both the scenes and cast members if you so wanted to!<
               @ The sky is the limit with this one, and it's one of the essential tools provided to you{space}
               with XVNML2U.{jump_to::"P3-XVNML2U-UnityComponents-Main"}<

               ["P3-XVNML2U-UnityComponents-XVNMLPromptControl"]
               @ The XVNMLPromptControl Componenet makes use of any lines with an Interrogative Role.<
               @ For every text surrounded by parentheses and followed with a {tag_end}, it'll take the array{space}
               of data, and turn them into buttons for the player to press on.<
               @ When you selected a prompt, the response value is the index of that response.<
               @ XVNML then knows the starting point after answering that prompt, as well as 
               the ending point after answering the prompt.<
               @ By default, you can have up to 12 prompts to be viewed simultaneously.<
               @ I don't know why you would want that much, but it's there for you if you want to have that many.<
               @ A nice trick to use with Prompts is combining Named Lines with the {paren}jump_to{paren_end}{space}
               macro.<
               @ Honestly, this will be a lot easier on the XVNML parser, because it reduces the amount of nesting.<
               @ The bigger the nesting, the more XVNML will have to work to resolve the starting and ending points{space}
               of those dialogue.<
               @ The XVNMLEssentials.main.xvnml file exemplifies this greatly, showing how after selecting a{space}
               choice, it jumps to whatever label you want that response to go to.<
               @ It also makes your XVNML document a lot nicer.<
               @ Of course, you can type out your document however you want.<
               @ If it's easier branching prompts in, then you can do it.<
               @ Otherwise, make use of Named Lines and the {paren}jump_to{paren_end} macro for{space}
               nicer looking mark-up.{jump_to::"P3-XVNML2U-UnityComponents-Main"}<

               ["P3-XVNML2U-UnityComponents-ResponseControl"]
               @ The ResponseControl Component is a component that must be a child of the gameObject with the{space}
               XVNMLPromptControl component.<
               @ This component receives information grabbed from the XVNMLPromptControl component, and displays{space}
               its content to the user.<
               @ It also allows the user to response with the prompt given to them.<
               @ There are 12 gameObjects with this components, and receiving all information from the{space}
               XVNMLPromptControl componenent.<
               @ That's about it really.{jump_to::"P3-XVNML2U-UnityComponents-Main"}<

               ["P3-XVNML2U-UnityComponents-XVNMLAudioController"]
               @  <
               @ {jump_to::"P3-XVNML2U-UnityComponents-Main"}<

               ["P3-XVNML2U-UnityComponents-Complete"]
               @  <
               @ {jump_to::"Main"}<

          #//endregion

          #//Integrate XVNML Manually

               ["P4"]
               @ {set_text_speed::40}Filler Dialogue...
               {jump_to::"Main"}<
          
          #//endregion

          #//Some Best Practics
               
               ["P5"]
               @ {set_text_speed::40}Filler Dialogue...
               {jump_to::"Main"}<

          #//endregion

          #//End Demo

               ["CL"]
               @ {set_text_speed::40}We hope that you've enjoyed this demo.<
               @ Please consider loading the other Unity Scenes to 
               get a more in-depth explanation on the different tools and features
               that XVNML and XVNML2U can provide.<
               @ With that said, logging out!<<

          #//endregion
     </dialogue>
</proxy>